{"./":{"url":"./","title":"目录","keywords":"","body":"目录 目录 算法基础 二分查找 冒泡排序 快速排序 归并排序 堆排序 速查表 算法实战 语言 中间件 架构 Copyright © channingbreeze.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-03 20:05:36 "},"codes/basic/BINARY_SEARCH.html":{"url":"codes/basic/BINARY_SEARCH.html","title":"二分查找","keywords":"","body":" 前言 写这篇文章前，我看了很多讲二分查找的文章，包括公众号和知乎的，在我看来，讲得都比较差，说几点原因： 1、要么只讲最简单的情况 2、要么讲了稍复杂的情况，但是一会儿闭区间一会儿开区间，一会儿加一减一，一会儿又不加减，一会儿还要打个补丁 二分法细节确实比较多，但是真正理解之后，是可以有一个通用模板的，根本不需要考虑到底是开区间还是闭区间，加一还是减一还是不加减，更不需要打补丁。 本文只讲最基础的情况，但是我认为最基础的情况，至少也包括五种，而我看到的目前市面上的文章，很少讲全了五种。 我们先假设数组是升序排列，再给你一个数target。 题目总共可能有五种情况，这五种情况分别是： 1、最基础版，只要找到target就行，返回下标，找不到返回-1 2、进阶版一，找到等于target的左边界(数组中可能有多个数都等于target)，找不到返回-1 3、进阶版二，找到等于target的右边界(数组中可能有多个数都等于target)，找不到返回-1 4、进阶版三，找到小于target的最大值，找不到返回-1 5、进阶版四，找到大于target的最小值，找不到返回-1 最基础版二分法 首先你需要知道最基础版应该怎么写，二分法的思想其实很简单，就是先取中间的数，然后和target比较，如果小了就往右找，大了就往左找。然后再取中间数，如此循环，直到中间没有数了。 思路我相信大家都能理解，但是在写法上，实际上还有一个双指针的思想，也就是我们需要left和right两个指针，然后不断调整两个指针的位置，最终得到答案。 废话不多说，我们看一下代码。 public static int commonBinarySearch(int[] arr, int target) { int left = 0, right = arr.length - 1; while(left 代码其实很简单我就不多解释了。 我相信可能有同学看过其他版本，比如所谓的开区间版本，但是我告诉大家，没有必要去看去记这么多版本，你只要会一种就能行走天下，而我建议大家就写上面这种。 这种也叫闭区间版本，每一个数都会搜索到，需要注意的几个点 1、right初始是arr.length-1，很好理解，因为这是数组右边界下标 2、while里面是left 3、区间范围缩小时，left=mid+1或者right=mid-1，也好理解，因为arr[mid]已经不是我们要找的数，所以范围需要加一或者减一 之所以要推荐闭区间版本，是因为它最符合我们的直观逻辑，而且它是对称的，是把left和right一视同仁，而不会像有的版本left需要加一，但是right却不需要减一。 进阶版 有了基础模板，我们怎么去做进阶版呢？大家可以先思考一下第二个问题。 说实话，如果是第一次碰到这个问题，还真不一定能找到最优解，第一个直观感受可能是我找到mid后，在往左一个一个地看，看看哪里是边界，但是这样，时间复杂度可能退化成o(n)。 其实还是应该用二分的思想找，关键在于arr[mid]==target时候的处理。 我们来看一下我的解法。 public static int firstBinarySearch(int[] arr, int target) { int left = 0, right = arr.length - 1; int res = -1; while(left 这里的一个技巧就是当arr[mid]==target时，因为要找左边界，我们把right=mid-1，也就是改变右边界从而缩小范围。这时候其实存在两种情况，要么答案已经是res(左边界)，[left,right]里面已经没有答案，while再也不会更新res，最终返回res是正确的，要么res还不是最终答案，那么答案就会在[left,right]里面，而在while中，我们总能找到它从而更新res，最终返回res也是正确的。 这里我们额外定义了一个res表示结果，这一步是整个解法的精髓。相对于很多其他教程在考虑到底是返回left还是left+1还是right还是right-1，直接定义一个res要好理解得多。 这里也要注意几点： 1、res一定是符合条件的，比如在这里，我们只有当arr[mid]==target的时候，我们才会更新res。 2、res会随着搜索范围减小越来越接近答案，当搜索结束时，res就是答案。 3、如果一次都没有更新res，说明整个数组里没有满足条件的数，res应该为-1，也就是初始值。 理解了第二问你再做第三问，我相信你直接看代码就行，都不需要我解释。 public static int lastBinarySearch(int[] arr, int target) { int left = 0, right = arr.length - 1; int res = -1; while(left 同样，你做第四问和第五问，只需要考虑什么时候更新res，因为第四问要找的数是小于target的，所以应该在arr[mid]target时更新res。 第四问： public static int lowerBiggest(int[] arr, int target) { int left = 0, right = arr.length - 1; int res = -1; while(left 第五问： public static int higherSmallest(int[] arr, int target) { int left = 0, right = arr.length - 1; int res = -1; while(left 题外话 通过这个问题，我也说说题外话。我记得曾经看过linus的一个视频，其中一个点我印象很深刻，他举了一个单链表删除节点的例子，他说所有的教科书都会告诉我们要分情况，删除头节点和删除一个中间节点是不一样的逻辑。但是他觉得不是，他说要从另外一个角度看，这两种情况可以统一，而一个逻辑统一的代码才是好代码。 练习题 学习完二分查找，大家可以去做一下以下的习题： leetcode704 二分查找 leetcode34 在排序数组中查找第一个和最后一个元素 leetcode35 搜索插入位置 leetcode33 搜索旋转排序数组 leetcode162 寻找峰值 还不会的话关注我，后续讲解。 原文链接 Copyright © channingbreeze.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-03 18:47:33 "},"codes/basic/BUBBLE_SORT.html":{"url":"codes/basic/BUBBLE_SORT.html","title":"冒泡排序","keywords":"","body":" 前言 只要学过编程，多多少少会接触到冒泡排序，这是一个非常直观的排序算法，不太需要费脑筋就能理解。 但是题目简单不代表面试简单，面试不仅仅是要把题目做出来，还要比别的面试候选人做得更好，这就得对冒泡排序研究一番。 90%人都能写出来的代码 不出意外，学过一点编程的人，稍微准备一下，都能写出来这个版本。 public static void swap(int[] arr, int i, int j) { int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } public static void bubbleSort(int[] arr) { for(int i = 0; i = i; j--) { if(arr[j] > arr[j + 1]) { swap(arr, j, j + 1); } } } } 其实实现的关键就是计算需要排多少趟，以及每趟需要交换多少次，只要这个计算没问题，代码实现还是比较简单的。 这是把最小的往上冒泡，当然你也可以把最大的往下“沉”，但是这时候如果面试官问你还能不能优化，你会怎么办？ 优化 大部分的教科书提供了上面这种实现就没有再往下讲了。如果你平时根本没思考过怎么优化，那被问到的时候，可能一时半会儿还真想不出来。 首先你可以这样想，上面的实现其实每次都要排arr.length - 1趟，假如第1趟就已经有序，后面的不是都白白浪费了吗？所以第一个优化点就是定义一个变量，来判断每一趟排序后是否已经有序。 public static void swap(int[] arr, int i, int j) { int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } public static void bubbleSort(int[] arr) { for(int i = 0; i = i; j--) { if(arr[j] > arr[j + 1]) { swap(arr, j, j + 1); isSorted = false; } } if(isSorted) { return; } } } 到这里，应该可以甩掉70%的人了，但是面试官还想继续压榨，问了句还能再优化吗？ 到这里想再优化不是一件容易的事情，不过你再仔细想想排序的细节，我们每次都是从后往前比较交换，但是假如上一趟交换从某个点开始，前面的都已经有序了，下一趟的时候是不是就可以不用再去比较和交换那个点前面的数据了？ 所以这里我们可以再定义一个变量来完成这件事情。 public static void swap(int[] arr, int i, int j) { int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } public static void bubbleSort(int[] arr) { int lastExchangeIndex = 0; for(int i = 0; i = sortBorder; j--) { if(arr[j] > arr[j + 1]) { swap(arr, j, j + 1); isSorted = false; lastExchangeIndex = j; } } if(isSorted) { return; } } } 到这里已经向面试官展示了你的深入思考能力，这道题大概率能过了。 拓展 如果面试官还是那句话，还能继续优化吗？其实还有优化的手段，有一种双向冒泡的方法，但是代码量会增加一倍，一般面试不会让写，如果真的被问到，可以说一下思路，读者也可以想想双向冒泡能解决什么问题，作为拓展阅读吧。 练习题 学习完冒泡排序，大家可以去做一下以下的习题： leetcode912 排序数组 leetcode147 链表排序 原文链接 Copyright © channingbreeze.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-03 18:47:30 "},"codes/basic/QUICK_SORT.html":{"url":"codes/basic/QUICK_SORT.html","title":"快速排序","keywords":"","body":" 前言 这么多排序算法里面，我最喜欢考快速排序，也是我出去面试时被问到最多的，快速排序代码量适中，并且考察你设计函数和递归的能力，是非常适合用来面试的。 如果你还不明白快速排序的思路，可以看下上面的图，快速排序核心思想就是找到一个点，然后通过交换，让点左边的数都小于等于这个点的值，点右边的数都大于等于这个点的值，再在左右进行递归。 核心思想虽然一致，但是快速排序的写法还是很多的，这篇文章来介绍几种。 框架 首先我们明确命名，在快速排序中，我们找到的这个点一般叫做pivot，中文叫支点或者叫枢轴。我个人在考察别人代码的时候，命名是非常重要的考察点，我自己写代码也非常注重命名，也希望大家能够重视起来。 接下来我们来规划一下快排中需要哪些函数。首先swap最好还是抽成一个函数，就用来交换数组中的两个数。然后因为要递归，我们需要一个innerQuickSort(int[] arr, int start, int end)，用来进行从start到end的一个排序，最后我们需要一个innerFindPivot(int[] arr, int start, int end)，用于在start和end间找到一个pivot，并且使得pivot左边的数都小于等于pivot，右边的数都大于等于pivot。 接下来我们来看一下大体框架。 public static void swap(int[] arr, int i, int j) { int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } public static int innerFindPivot(int[] arr, int start, int end) { // TODO } public static void innerQuickSort(int[] arr, int start, int end) { int pivot = innerFindPivot(arr, start, end); if(start 真正的函数quickSort直接调用innerQuickSort，而innerQuickSort调用innerFindPivot找到pivot后，递归地调用innerQuickSort就能完成排序了。 所以真正核心的地方就是innerFindPivot。 三种方式 我们先看第一种方法，我们先将arr[start]作为pivot，然后处理后面的数，处理的时候我们使用双指针的思想，废话不多说，看下代码： public static void swap(int[] arr, int i, int j) { int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } public static int innerFindPivot(int[] arr, int start, int end) { int left = start, right = end; int pivot = arr[start]; while(left pivot) { right--; } while(left 这个方法需要注意的细节还是比较多的，首先必须先right--，然后再left++，否则会有问题，具体为啥读者可以自行模拟一下。另外=是在left这边，最后返回也是返回left。 还有一个问题是pivot的选择，可以选第一个数，也可以选择一个随机数，选择随机数就先和第一个数交换，然后再进行后续流程就行。 还有一种双边的方法是可以不用选择pivot的，我们一起看一下。 public static void swap(int[] arr, int i, int j) { int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } public static int innerFindPivot(int[] arr, int start, int end) { int left = start, right = end; boolean isLeft = true; while(left 这种是双边交换之后自动产生pivot的位置，不过你仔细模拟一下会发现，它其实也是选择了最后一个元素作为pivot，但是这种方法细节就少多了，而且left和right是对称的，所以我更喜欢这种方法。 还有一种单边的方法，也一起看一下，这种单边的方法相对双边会更简单一些。 public static void swap(int[] arr, int i, int j) { int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } public static int innerFindPivot(int[] arr, int start, int end) { int mark = start; int pivot = arr[start]; for(int i = start + 1; i 单边的思想就是保证mark的位置就是pivot的位置，这里也要注意一下，首先i一直是>=mark的，其次mark的位置是小于pivot的数的边界。 关于快排大家还是要细细体会，如果还没理解的话自己画图模拟一下，实在不行背也要背下来，我建议大家至少要能够手写其中一种方法。 练习题 学习完快速排序，大家可以去做一下以下的习题： leetcode912 排序数组 leetcode147 链表排序 原文链接 Copyright © channingbreeze.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-09 23:16:01 "},"codes/basic/MERGE_SORT.html":{"url":"codes/basic/MERGE_SORT.html","title":"归并排序","keywords":"","body":" 前言 归并排序也是面试中问得比较多的，代码量适中，也需要使用递归来实现，而且理解起来比快速排序要简单，实现方式也较为单一，所以也广受面试官的喜爱。 还没有了解归并排序原理的可以看一下上面的图，它其实就是先把要排序的数组分为左右两部分，左边和右边分别先递归排好序，然后再将两个有序的数组合并为一个数组。 实现 这里需要注意的就是我们需要一个innerMergeSort的函数实现递归，具体可以直接看下代码。 public static void innerMergeSort(int[] arr, int start, int end) { int mid = (end - start) / 2 + start; if(start 先找到mid，然后对start到mid和mid+1到end分别排序，最后将两个有序数组merge。在merge的时候，需要定义一个额外空间tmp，同时定义三个指针，分别指向两个有序数组和我们的目标数组。最后再将tmp的元素拷贝到原数组中。 应用 其实归并排序有一个特点，它不需要一次性将数据全部加载到内存，也就是说用它的思想可以排序很大的文件。这其实也就是外部排序的思想。 所以如果有面试官问你有一个10亿整数数据的文件，但是内存有限，你该怎么排序，你应该想到归并排序。 练习题 学习完归并排序，大家可以去做一下以下的习题： leetcode912 排序数组 leetcode147 链表排序 原文链接 Copyright © channingbreeze.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-09 23:16:11 "},"codes/basic/HEAP_SORT.html":{"url":"codes/basic/HEAP_SORT.html","title":"堆排序","keywords":"","body":" 前言 堆这种结构实在是用得太多了，而且一般考到的话都是中等或者困难的题，关键是在没有提示的情况下，初学者很难想到可以用堆来进行优化。 如果对堆还没概念，我这里简单描述一下。堆是一种二叉树，分大顶堆和小顶堆，大顶堆就是根元素要大于左右两边的元素，并且左右两边都是大顶堆。小顶堆相反，根元素小于左右两边的元素，并且左右两边都是小顶堆。 所以对于堆来说，堆顶元素是整个堆的最值。堆排序就是利用了堆的这个性质，每次将堆顶元素取出，然后剩余元素调整形成新的堆，再次将堆顶元素取出，这样最终就能排序了。 外援 首先我们可以用语言自己提供的堆的实现来实现堆排序，看下代码。 public static void heapSort(int[] arr) { PriorityQueue heap = new PriorityQueue<>(); for(int i = 0; i 在java中，PriorityQueue就是堆（也叫优先队列），offer方法是把一个元素加入到堆里面，并且内部进行调整，使它重新满足堆的条件，poll方法是将堆顶元素取出，并且内部进行调整，使其他元素重新满足堆的条件。 有了上面的知识我们很简单就能理解了，我们直接把数组放到堆里，然后一个个从堆顶取出就好，这样就自动排好序了。 如果考堆排序，面试官一般不会让你用PriorityQueue，但是我们也得会，因为如果其他题用到堆，一般是可以直接用PriorityQueue的。 内功 自己实现，我们其实就是去实现调整堆的逻辑。先看一下代码，我们对着代码讲。 public static void swap(int[] arr, int i, int j) { int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } public static void downAdjust(int[] arr, int parent, int end) { int left = parent * 2, right = parent * 2 + 1; if(left > end) { return; } if(right = 0; i--) { downAdjust(arr, i, arr.length - 1); } for(int i = arr.length - 1; i > 0; i--) { swap(arr, 0, i); downAdjust(arr, 0, i - 1); } } 其实主要分两步，第一步先把原来的数组变成一个堆，我们从arr.length/2开始，因为再往后都是叶子节点，没必要调整了。而每次调整，我们调用的是downAdjust，这个是核心方法。 在downAdjust里面，一定要注意定义一个end作为边界，然后找到左右孩子，将parent和左右孩子中较大的交换，交换之后将parent设为孩子的位置，再继续递归。 这样全部调整完之后，就会形成一个大顶堆，然后从后往前，每次把堆顶和数组元素交换，这样数组就变成有序数组啦。 说实话这个实现还是有一定技巧的，面试中出现的也不多，但是堆这个数据结构一定要掌握，面试很有帮助。 练习题 学习完堆排序，大家可以去做一下以下的习题： leetcode912 排序数组 leetcode147 链表排序 原文链接 Copyright © channingbreeze.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-09 23:16:19 "},"codes/basic/CHEAT_SHEET.html":{"url":"codes/basic/CHEAT_SHEET.html","title":"速查表","keywords":"","body":"排序 数组排序 int[] arr = new int[] {7, 4, 1, 5, 6}; Arrays.sort(arr); List排序 List list = Arrays.asList(7, 4, 1, 5, 6); Collections.sort(list); 数组转List int[] arr = new int[] {7, 4, 1, 5, 6}; List list = Arrays.stream(arr).boxed().collect(Collectors.toList()); List转数组 List list = Arrays.asList(7, 4, 1, 5, 6); int[] arr = list.stream().mapToInt(Integer::valueOf).toArray(); Copyright © channingbreeze.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-09 23:16:26 "}}